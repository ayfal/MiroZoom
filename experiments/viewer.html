<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Viewer - Shared Screen</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden}
    #overlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;z-index:10}
    #waiting{background:rgba(0,0,0,0.7);color:#fff;padding:20px 28px;border-radius:8px;font-size:28px;font-weight:700}
    video{
      position:fixed;left:0;top:0;width:100%;height:100%;object-fit:contain;
      touch-action: none; transform-origin: 0 0;
      -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>
  <div id="overlay"><div id="waiting">Waiting for host</div></div>
  <video id="screenVideo" autoplay playsinline></video>

  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script>
    const HOST_ID = 'unique-studyroom-for-host-and-visually-impaired';
    const video = document.getElementById('screenVideo');
    const overlay = document.getElementById('overlay');
    const waiting = document.getElementById('waiting');

    const peer = new Peer({
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          {
            urls: 'turn:openrelay.metered.ca:443?transport=tcp',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          }
        ]
      }
    });

    let dataConn = null;
    let currentCall = null;

    function hideWaiting() { overlay.style.display = 'none'; }
    function showWaiting(msg = 'Waiting for host') { waiting.textContent = msg; overlay.style.display = 'flex'; }

    peer.on('open', id => {
      // automatically connect to host so host can call back
      dataConn = peer.connect(HOST_ID);
      dataConn.on('open', () => {
        // ready to receive call from host
        dataConn.on('data', d => {
          if (d === 'end') stopReceiving();
        });
      });
      dataConn.on('error', () => { dataConn = null; });
      dataConn.on('close', () => { dataConn = null; showWaiting('Waiting for host'); });
      showWaiting('Waiting for host');
    });

    peer.on('call', call => {
      try {
        currentCall = call;
        call.answer(); // answer with no local stream (viewer only receives)
        call.on('stream', stream => {
          dbg && dbg('viewer received stream');
          // set the remote stream as the video source
          video.srcObject = stream;
          // wait for play success before confirming to host
          const tryConfirm = () => {
            if (dataConn && dataConn.open) {
              try { dataConn.send('viewing'); } catch(e){ console.warn('failed send viewing', e); }
            }
          };
          video.play().then(() => {
            hideWaiting();
            tryConfirm();
          }).catch(() => {
            // still send viewing even if autoplay blocks; host expects confirmation
            hideWaiting();
            tryConfirm();
          });
        });
        call.on('close', () => stopReceiving());
        call.on('error', () => stopReceiving());
      } catch(e) {
        console.error('Call handling error', e);
      }
    });

    function stopReceiving() {
      try {
        if (video.srcObject) {
          video.srcObject = null;
        }
      } catch(e){}
      try { if (currentCall) currentCall.close(); } catch(e){}
      currentCall = null;
      try { peer.destroy(); } catch(e){}
      showWaiting('Session ended');
    }

    peer.on('error', err => {
      console.error('Peer error', err);
      showWaiting('Connection error');
    });

    // ---- pinch zoom + pan (touch + mouse) ----
    let scale = 1, lastScale = 1;
    let pos = {x:0,y:0}, lastPos = {x:0,y:0};
    let startTouches = [];

    function setTransform() {
      video.style.transform = `translate(${pos.x}px, ${pos.y}px) scale(${scale})`;
    }

    // touch handlers
    video.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        startTouches = [{x:e.touches[0].clientX, y:e.touches[0].clientY}];
        lastPos = {...pos};
      } else if (e.touches.length === 2) {
        startTouches = [
          {x:e.touches[0].clientX, y:e.touches[0].clientY},
          {x:e.touches[1].clientX, y:e.touches[1].clientY}
        ];
        lastScale = scale;
      }
    }, {passive:true});

    video.addEventListener('touchmove', e => {
      e.preventDefault();
      if (e.touches.length === 1 && startTouches.length === 1) {
        const dx = e.touches[0].clientX - startTouches[0].x;
        const dy = e.touches[0].clientY - startTouches[0].y;
        pos.x = lastPos.x + dx;
        pos.y = lastPos.y + dy;
        setTransform();
      } else if (e.touches.length === 2 && startTouches.length === 2) {
        const curDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        const startDist = Math.hypot(
          startTouches[0].x - startTouches[1].x,
          startTouches[0].y - startTouches[1].y
        );
        if (startDist > 0) {
          scale = Math.max(0.5, Math.min(5, lastScale * (curDist / startDist)));
          setTransform();
        }
      }
    }, {passive:false});

    video.addEventListener('touchend', e => {
      if (e.touches.length === 0) {
        startTouches = [];
        lastScale = scale;
        lastPos = {...pos};
      }
    });

    // mouse support for desktop: wheel to zoom, drag to pan
    let dragging = false;
    let dragStart = {x:0,y:0};

    video.addEventListener('mousedown', e => {
      dragging = true;
      dragStart = {x:e.clientX, y:e.clientY};
      lastPos = {...pos};
    });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      pos.x = lastPos.x + (e.clientX - dragStart.x);
      pos.y = lastPos.y + (e.clientY - dragStart.y);
      setTransform();
    });
    window.addEventListener('mouseup', () => { dragging = false; lastPos = {...pos}; });

    video.addEventListener('wheel', e => {
      e.preventDefault();
      const delta = -e.deltaY;
      const factor = delta > 0 ? 1.08 : 0.92;
      const newScale = Math.max(0.5, Math.min(5, scale * factor));
      // zoom towards cursor: adjust pos to keep cursor point stable
      const rect = video.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;
      const prevScale = scale;
      scale = newScale;
      pos.x = cx - (cx - pos.x) * (scale / prevScale);
      pos.y = cy - (cy - pos.y) * (scale / prevScale);
      setTransform();
    }, {passive:false});
  </script>
</body>
</html>