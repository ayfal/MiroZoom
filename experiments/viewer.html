<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Viewer - Shared Screen</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden}
    #overlay{position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;z-index:10}
    #waiting{background:rgba(0,0,0,0.7);color:#fff;padding:20px 28px;border-radius:8px;font-size:28px;font-weight:700}
    video{
      position:fixed;left:0;top:0;width:100%;height:100%;object-fit:contain;
      touch-action: none; transform-origin: 0 0;
      -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>
  <div id="overlay"><div id="waiting">Waiting for host</div></div>
  <video id="screenVideo" autoplay playsinline></video>

  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script>
    // viewer debug helper
    window.viewerDebugLogs = window.viewerDebugLogs || [];
    function vdbg(...args) {
      try {
        const msg = args.map(a => (typeof a === 'object' ? JSON.stringify(a) : String(a))).join(' ');
        console.log('[VIEWER DEBUG]', msg);
        window.viewerDebugLogs.push(`[${new Date().toISOString()}] ${msg}`);
        if (window.viewerDebugLogs.length > 500) window.viewerDebugLogs.shift();
      } catch (e) { console.log('[VIEWER DEBUG] (log error)', e); }
    }
    window.getViewerDebugLogs = () => (window.viewerDebugLogs || []).slice();

    const HOST_ID = 'unique-studyroom-for-host-and-visually-impaired';
    const video = document.getElementById('screenVideo');
    const overlay = document.getElementById('overlay');
    const waiting = document.getElementById('waiting');

    // ensure autoplay isn't blocked: start muted so video.play() is allowed
    video.muted = true;
    vdbg('video element muted to allow autoplay');

    vdbg('Initializing viewer script', { HOST_ID });

    const peer = new Peer({
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          {
            urls: 'turn:openrelay.metered.ca:443?transport=tcp',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          }
        ]
      }
    });

    vdbg('Peer object created, waiting for open');

    let dataConn = null;
    let currentCall = null;

    function hideWaiting() { overlay.style.display = 'none'; vdbg('hideWaiting'); }
    function showWaiting(msg = 'Waiting for host') { waiting.textContent = msg; overlay.style.display = 'flex'; vdbg('showWaiting', msg); }

    peer.on('open', id => {
      vdbg('peer.on(open)', id);
      showWaiting('Connected to signaling');
      // automatically connect to host so host can call back
      try {
        dataConn = peer.connect(HOST_ID);
        vdbg('dataConn created to', HOST_ID);
        showWaiting('Connecting to host');
        dataConn.on('open', () => {
          vdbg('dataConn open with', dataConn.peer);
          showWaiting('Connected to host');
          dataConn.on('data', d => {
            vdbg('dataConn received', d);
            if (d === 'end') {
              vdbg('received end via dataConn');
              stopReceiving();
            }
          });
        });
        dataConn.on('error', err => { vdbg('dataConn error', err); dataConn = null; showWaiting('Connection error'); });
        dataConn.on('close', () => { vdbg('dataConn closed'); dataConn = null; showWaiting('Waiting for host'); });
      } catch (e) {
        vdbg('dataConn setup failed', e);
        showWaiting('Connection error');
      }
    });

    peer.on('call', call => {
      vdbg('peer.on(call) from', call.peer);
      showWaiting('Incoming call');
      try {
        currentCall = call;
        call.on('close', () => { vdbg('incoming call closed'); showWaiting('Waiting for host'); });
        call.on('error', err => { vdbg('incoming call error', err); showWaiting('Call error'); });
        call.answer(); // answer with no local stream (viewer only receives)
        vdbg('call.answer() sent');
        call.on('stream', stream => {
          vdbg('call.on(stream) received', { tracks: stream.getTracks().map(t => t.kind + ':' + t.id) });
          // set the remote stream as the video source
          video.srcObject = stream;
          const tryConfirm = () => {
            if (dataConn && dataConn.open) {
              try {
                dataConn.send('viewing');
                vdbg('sent viewing confirmation to host');
              } catch(e){ vdbg('failed send viewing', e); }
            } else {
              vdbg('no dataConn open to send viewing');
            }
          };
          video.play().then(() => {
            vdbg('video.play() succeeded');
            showWaiting('Viewing');
            // hide after short delay so user sees message then full-screen content is visible
            setTimeout(hideWaiting, 300);
            tryConfirm();
          }).catch(err => {
            vdbg('video.play() failed or blocked', err);
            showWaiting('Viewing (autoplay blocked)');
            setTimeout(hideWaiting, 300);
            // still confirm viewing to host so host can show preview
            tryConfirm();
          });
        });
      } catch(e) {
        vdbg('Call handling error', e);
        console.error('Call handling error', e);
      }
    });

    function stopReceiving() {
      vdbg('stopReceiving called');
      try {
        if (video.srcObject) {
          video.srcObject = null;
          vdbg('cleared video.srcObject');
        }
      } catch(e){ vdbg('error clearing video.srcObject', e); }
      try { if (currentCall) { currentCall.close(); vdbg('closed currentCall'); } } catch(e){ vdbg('error closing currentCall', e); }
      currentCall = null;
      try { peer.destroy(); vdbg('peer.destroy() called'); } catch(e){ vdbg('peer.destroy() failed', e); }
      showWaiting('Session ended');
    }

    peer.on('error', err => {
      vdbg('Peer error', err && err.message ? err.message : err);
      showWaiting('Connection error');
    });

    // ---- pinch zoom + pan (touch + mouse) ----
    let scale = 1, lastScale = 1;
    let pos = {x:0,y:0}, lastPos = {x:0,y:0};
    let startTouches = [];

    function setTransform() {
      video.style.transform = `translate(${pos.x}px, ${pos.y}px) scale(${scale})`;
    }

    video.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        startTouches = [{x:e.touches[0].clientX, y:e.touches[0].clientY}];
        lastPos = {...pos};
      } else if (e.touches.length === 2) {
        startTouches = [
          {x:e.touches[0].clientX, y:e.touches[0].clientY},
          {x:e.touches[1].clientX, y:e.touches[1].clientY}
        ];
        lastScale = scale;
      }
    }, {passive:true});

    video.addEventListener('touchmove', e => {
      e.preventDefault();
      if (e.touches.length === 1 && startTouches.length === 1) {
        const dx = e.touches[0].clientX - startTouches[0].x;
        const dy = e.touches[0].clientY - startTouches[0].y;
        pos.x = lastPos.x + dx;
        pos.y = lastPos.y + dy;
        setTransform();
      } else if (e.touches.length === 2 && startTouches.length === 2) {
        const curDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        const startDist = Math.hypot(
          startTouches[0].x - startTouches[1].x,
          startTouches[0].y - startTouches[1].y
        );
        if (startDist > 0) {
          scale = Math.max(0.5, Math.min(5, lastScale * (curDist / startDist)));
          setTransform();
        }
      }
    }, {passive:false});

    video.addEventListener('touchend', e => {
      if (e.touches.length === 0) {
        startTouches = [];
        lastScale = scale;
        lastPos = {...pos};
      }
    });

    let dragging = false;
    let dragStart = {x:0,y:0};

    video.addEventListener('mousedown', e => {
      dragging = true;
      dragStart = {x:e.clientX, y:e.clientY};
      lastPos = {...pos};
    });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      pos.x = lastPos.x + (e.clientX - dragStart.x);
      pos.y = lastPos.y + (e.clientY - dragStart.y);
      setTransform();
    });
    window.addEventListener('mouseup', () => { dragging = false; lastPos = {...pos}; });

    video.addEventListener('wheel', e => {
      e.preventDefault();
      const delta = -e.deltaY;
      const factor = delta > 0 ? 1.08 : 0.92;
      const newScale = Math.max(0.5, Math.min(5, scale * factor));
      const rect = video.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;
      const prevScale = scale;
      scale = newScale;
      pos.x = cx - (cx - pos.x) * (scale / prevScale);
      pos.y = cy - (cy - pos.y) * (scale / prevScale);
      setTransform();
    }, {passive:false});
  </script>
</body>
</html>