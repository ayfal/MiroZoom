<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Viewer - Shared Screen</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden}
    video{
      position:fixed;left:0;top:0;width:100%;height:100%;object-fit:contain;
      touch-action: none; /* allow pinch/pan handling */
      transform-origin: 0 0;
      -webkit-user-select:none; user-select:none; -webkit-tap-highlight-color: transparent;
    }
  </style>
</head>
<body>
  <video id="screenVideo" autoplay playsinline></video>

  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script>
    const HOST_ID = 'unique-studyroom-for-host-and-visually-impaired';
    const video = document.getElementById('screenVideo');

    // ICE servers: Google STUN + OpenRelay TURN (demo credentials)
    const peer = new Peer({
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          {
            urls: 'turn:openrelay.metered.ca:443?transport=tcp',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          }
        ]
      }
    });

    let localStream = null;
    let dataConn = null;

    async function startShare() {
      try {
        localStream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
      } catch (e) {
        console.error('Screen share denied or failed', e);
        return;
      }

      // show local captured screen full-window (no UI elements)
      video.srcObject = localStream;
      try { await video.play(); } catch(e){}

      // call host and send stream
      const call = peer.call(HOST_ID, localStream);
      // open data connection so host can send stop message
      dataConn = peer.connect(HOST_ID);
      dataConn.on('open', () => {
        dataConn.on('data', d => {
          if (d === 'end') stopSharingAndClose();
        });
      });
      call.on('close', () => stopSharingAndClose());
      call.on('error', () => stopSharingAndClose());
    }

    function stopSharingAndClose() {
      try {
        if (localStream) {
          localStream.getTracks().forEach(t => t.stop());
          localStream = null;
        }
      } catch(e){}
      try { peer.destroy(); } catch(e){}
      // keep page minimal; stop video display
      video.srcObject = null;
    }

    peer.on('open', id => {
      // automatically begin capture and call host
      startShare();
    });

    peer.on('error', err => {
      console.error('Peer error', err);
    });

    // ---- pinch zoom + pan (touch + mouse) ----
    let scale = 1, lastScale = 1;
    let pos = {x:0,y:0}, lastPos = {x:0,y:0};
    let startTouches = [];

    function setTransform() {
      video.style.transform = `translate(${pos.x}px, ${pos.y}px) scale(${scale})`;
    }

    // touch handlers
    video.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        startTouches = [{x:e.touches[0].clientX, y:e.touches[0].clientY}];
        lastPos = {...pos};
      } else if (e.touches.length === 2) {
        startTouches = [
          {x:e.touches[0].clientX, y:e.touches[0].clientY},
          {x:e.touches[1].clientX, y:e.touches[1].clientY}
        ];
        lastScale = scale;
      }
    }, {passive:true});

    video.addEventListener('touchmove', e => {
      e.preventDefault();
      if (e.touches.length === 1 && startTouches.length === 1) {
        const dx = e.touches[0].clientX - startTouches[0].x;
        const dy = e.touches[0].clientY - startTouches[0].y;
        pos.x = lastPos.x + dx;
        pos.y = lastPos.y + dy;
        setTransform();
      } else if (e.touches.length === 2 && startTouches.length === 2) {
        const curDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        const startDist = Math.hypot(
          startTouches[0].x - startTouches[1].x,
          startTouches[0].y - startTouches[1].y
        );
        if (startDist > 0) {
          scale = Math.max(0.5, Math.min(5, lastScale * (curDist / startDist)));
          setTransform();
        }
      }
    }, {passive:false});

    video.addEventListener('touchend', e => {
      if (e.touches.length === 0) {
        startTouches = [];
        lastScale = scale;
        lastPos = {...pos};
      }
    });

    // mouse support for desktop: wheel to zoom, drag to pan
    let dragging = false;
    let dragStart = {x:0,y:0};

    video.addEventListener('mousedown', e => {
      dragging = true;
      dragStart = {x:e.clientX, y:e.clientY};
      lastPos = {...pos};
    });
    window.addEventListener('mousemove', e => {
      if (!dragging) return;
      pos.x = lastPos.x + (e.clientX - dragStart.x);
      pos.y = lastPos.y + (e.clientY - dragStart.y);
      setTransform();
    });
    window.addEventListener('mouseup', () => { dragging = false; lastPos = {...pos}; });

    video.addEventListener('wheel', e => {
      e.preventDefault();
      const delta = -e.deltaY;
      const factor = delta > 0 ? 1.08 : 0.92;
      const newScale = Math.max(0.5, Math.min(5, scale * factor));
      // zoom towards cursor: adjust pos to keep cursor point stable
      const rect = video.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;
      const prevScale = scale;
      scale = newScale;
      pos.x = cx - (cx - pos.x) * (scale / prevScale);
      pos.y = cy - (cy - pos.y) * (scale / prevScale);
      setTransform();
    }, {passive:false});
  </script>
</body>
</html>